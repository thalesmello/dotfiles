" Mappings
nnoremap <leader>elv :vsplit ~/.vimrc.local<cr>
nnoremap <leader>slv :source ~/.vimrc.local<cr>
nnoremap <leader>. `>
nnoremap <leader>/ :CtrlPTag<CR>
nnoremap <leader>ss :w<cr>
noremap <leader>c :!
nmap <leader>tb :TagbarToggle<CR>
map ; :
noremap ;; ;
nmap <leader><C-n> <Plug>yankstack_substitute_newer_paste
inoremap <C-@> <C-n>
" Map multicursors
nmap <c-n> :call multiple_cursors#new("n", 1)<CR>
let g:multi_cursor_exit_from_insert_mode = 0
let g:multi_cursor_exit_from_visual_mode = 0
highlight multiple_cursors_cursor term=reverse cterm=reverse gui=reverse
highlight link multiple_cursors_visual Visual
set wildmode=list:longest,full

set listchars=tab:▸\ ,eol:¬

let g:tagbar_left = 1
let g:tagbar_autoclose = 1
let g:tagbar_autofocus = 1

if &term =~ '^screen'
    " tmux knows the extended mouse mode
    set ttymouse=xterm2
endif

nmap f <Plug>Sneak_s
nmap F <Plug>Sneak_S
xmap f <Plug>Sneak_s
xmap F <Plug>Sneak_S
omap f <Plug>Sneak_s
omap F <Plug>Sneak_S
let g:sneak#streak = 1
let g:sneak#s_next = 1

nnoremap <F6> :resize -5<CR>
nnoremap <F7> :resize +5<CR>
nnoremap <F8> :vertical resize -5<CR>
nnoremap <F9> :vertical resize +5<CR>

set lazyredraw

" Don't wait for ESC to timeout
set timeoutlen=1000 ttimeoutlen=0

" Vim Tmux Navigator
let g:tmux_navigator_no_mappings = 1
nnoremap <silent> <C-H> :TmuxNavigateLeft<cr>
nnoremap <silent> <C-J> :TmuxNavigateDown<cr>
nnoremap <silent> <C-K> :TmuxNavigateUp<cr>
nnoremap <silent> <C-L> :TmuxNavigateRight<cr>
nnoremap <silent> <C-\> :TmuxNavigatePrevious<cr>

set linebreak

" Devdocs
augroup plugin-devdocs
  autocmd!
  autocmd FileType c,cpp,rust,haskell,python,javascript,html,eruby,ruby nmap <buffer>K <Plug>(devdocs-under-cursor)
  autocmd FileType c,cpp,rust,haskell,python,javascript,html,eruby,ruby vmap <buffer>K y:DevDocs <C-R>"<CR>
  autocmd FileType * nmap <buffer>gK <Plug>(devdocs-under-cursor-all)
  autocmd FileType * vmap <buffer><silent>gK y:DevDocsAll <C-R>"<CR>
augroup END
let g:devdocs_filetype_map = {
    \   'ruby': 'ruby',
    \ }

" Remove yankstack enter mapping
" nunmap <cr>

" Semantic highlighting
let g:semanticTermColors = [28,1,2,3,87,5,6,7,81,9,10,34,11,13,14,15,165,154,49,139]
nnoremap <Leader>sh :SemanticHighlightToggle<cr>

" Automatic variable highlighting
" augroup color-variable
" 	autocmd!
" 	autocmd CursorMoved * exe printf('match Label /\V\<%s\>/', escape(expand('<cword>'), '/\'))
" augroup end
