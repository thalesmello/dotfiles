let maplocalleader = "'"
set cursorline
" Mappings
nnoremap <leader>. `>
nnoremap <leader>ss :w<cr>
nnoremap <leader>saa ggVG
nnoremap <leader>saq ?\v('''\|""")<CR>vw//e<CR>
nnoremap <leader>siq ?\v('''\|""")<CR>wv//e<CR>ge
nmap <leader>tb :TagbarToggle<CR>
nmap <leader>/ *N
vmap <leader>/ *N
vmap <leader>c/ *Ncgn
nmap <leader>c/ *Ncgn
nmap <leader>of vafzO
inoremap <c-u> <c-g>u<c-u>
inoremap <c-w> <c-g>u<c-w>
nnoremap Y y$
vmap <leader>yj Jgvyu
nmap <leader>tn :tabnew<cr>
vmap <leader>tn y:tabnew<cr>p
nmap <leader>bn :vnew<cr>
vmap <leader>bn y:vnew<cr>p
nmap <leader>bc :bw<cr>
nnoremap <leader>bs :Sscratch<cr>
vmap <leader>bs y:Sscratch<cr>vaep
noremap <c-e> 2<c-e>
noremap <c-y> 2<c-y>
noremap gH H
noremap gL L

" Dein
command! DeinClean call map(dein#check_clean(), "system('rm -rf ' . v:val)")
command! DeinRecache call dein#recache_runtimepath()

" Move around text objects
nnoremap <localleader>s :exec "normal vi".nr2char(getchar())."\e`<"<CR>
nnoremap <localleader>e :exec "normal vi".nr2char(getchar())."\e`>"<CR>
nnoremap <localleader>S :exec "normal va".nr2char(getchar())."\e`<"<CR>
nnoremap <localleader>E :exec "normal va".nr2char(getchar())."\e`>"<CR>

" Set unnamed register as default clipboard
set clipboard=unnamed

" Tmux complete
nnoremap <leader>ut :set completefunc=tmuxcomplete#complete<cr>
nnoremap <leader>uy :set completefunc=youcompleteme#Complete<cr>
let g:tmuxcomplete#capture_args = '-J -S -'

" Called once right before you start selecting multiple cursors
function! Multiple_cursors_before()
    let s:old_ycm_auto_trigger = g:ycm_auto_trigger
    let g:ycm_auto_trigger = 0
endfunction

" Called once only when the multiple selection is canceled (default <Esc>)
function! Multiple_cursors_after()
    let g:ycm_auto_trigger = s:old_ycm_auto_trigger
endfunction

nmap <c-n> :call multiple_cursors#new("n", 1)<CR>
let g:multi_cursor_exit_from_insert_mode = 0
let g:multi_cursor_exit_from_visual_mode = 0
highlight multiple_cursors_cursor term=reverse cterm=reverse gui=reverse
highlight link multiple_cursors_visual Visual
set wildmode=list:longest,full

set listchars=tab:▸\ ,eol:¬

" Tagbar
let g:tagbar_left = 1
let g:tagbar_autoclose = 1
let g:tagbar_autofocus = 1
set updatetime=500

" Sneak
nnoremap s s
nmap f <Plug>(SneakStreak)
nmap F <Plug>(SneakStreakBackward)
xmap f <Plug>(SneakStreak)
xmap F <Plug>(SneakStreakBackward)
omap f <Plug>(SneakStreak)
omap F <Plug>(SneakStreakBackward)
let g:sneak#use_ic_scs = 1
let g:sneak#target_labels = "sfghjkl;qwertyuiopzxvbnm/SFGHJKL:QWERTYUOPZXCVBNM?"
let g:sneak#textobject_z = 0

set lazyredraw

" Don't wait for ESC to timeout
set timeoutlen=1000 ttimeoutlen=0

" Vim Tmux Navigator
let g:tmux_navigator_no_mappings = 1
nnoremap <silent> <C-H> :TmuxNavigateLeft<cr>
nnoremap <silent> <C-J> :TmuxNavigateDown<cr>
nnoremap <silent> <C-K> :TmuxNavigateUp<cr>
nnoremap <silent> <C-L> :TmuxNavigateRight<cr>
nnoremap <silent> <C-\> :TmuxNavigatePrevious<cr>

set linebreak

" Devdocs
augroup plugin-devdocs
    autocmd!
    autocmd FileType c,cpp,rust,haskell,python,javascript,html,eruby,ruby nmap <buffer>K <Plug>(devdocs-under-cursor)
    autocmd FileType c,cpp,rust,haskell,python,javascript,html,eruby,ruby vmap <buffer>K y:DevDocs <C-R>"<CR>
    autocmd FileType * nmap <buffer>gK <Plug>(devdocs-under-cursor-all)
    autocmd FileType * vmap <buffer><silent>gK y:DevDocsAll <C-R>"<CR>
augroup END
let g:devdocs_filetype_map = {
            \   'ruby': 'ruby',
            \ }

" Remove yankstack enter mapping
" nunmap <cr>

" Semantic highlighting
let g:semanticTermColors = [28,1,2,3,87,5,6,7,81,9,10,34,11,13,14,15,165,154,49,139]
nnoremap <Leader>sh :SemanticHighlightToggle<cr>

" Greplace options
set grepprg=ack
let g:grep_cmd_opts = '--noheading'

" Go to file ctrlp
nmap gf <c-p><c-\>w
vmap gf <esc><c-p><c-\>v

" Ack Options
if executable('ag')
    let g:ackprg ='ag --vimgrep'
endif

" By Xolox @ http://stackoverflow.com/questions/1533565/how-to-get-visually-selected-text-in-vimscript
function! s:get_visual_selection()
    " Why is this not a built-in Vim script function?!
    let [lnum1, col1] = getpos("'<")[1:2]
    let [lnum2, col2] = getpos("'>")[1:2]
    let lines = getline(lnum1, lnum2)
    let lines[-1] = lines[-1][: col2 - (&selection == 'inclusive' ? 1 : 2)]
    let lines[0] = lines[0][col1 - 1:]
    return join(lines, "\n")
endfunction

function! s:Chomp(string)
    return substitute(a:string, '\n\+$', '', '')
endfunction

function! s:visual_command() range
    let text = s:get_visual_selection()
    let cmd = input('Pipe: ', '', 'shellcmd')
    let @v = s:Chomp(system(cmd, text))
    execute 'normal! gv"vp'
endfunction

command! -range VisualCommand <line1>,<line2>call s:visual_command()
vnoremap <leader>\| :VisualCommand<CR>

" Airline
let g:airline_powerline_fonts = 1
let g:airline_theme = 'powerlineish'
" let g:airline_inactive_collapse = 0
let g:airline#extensions#disable_rtp_load = 1
let g:airline_extensions = ['neomake', 'tagbar', 'branch', 'tabline', 'ctrlp']
let g:airline#extensions#tagbar#flags = 'f'
let g:airline#extensions#branch#displayed_head_limit = 15

let s:tagbar_enabled = 1

function! AirlineInit()
    let g:airline_section_a = airline#section#create(['mode'])
    let g:airline_section_b = airline#section#create(['file', ' ', 'readonly'])
    if s:tagbar_enabled
        let g:airline_section_c = airline#section#create(['tagbar'])
    else
        let g:airline_section_c = airline#section#create([])
    endif
    let g:airline_section_x = airline#section#create([])
    let g:airline_section_y = airline#section#create(['%<', 'branch'])
    let g:airline_section_z = airline#section#create(['%p%% ', '%{g:airline_symbols.linenr}%#__accent_bold#%l%#__restore__#:%v'])
endfunction
autocmd User AirlineAfterInit call AirlineInit()

fun! s:ToggleAirlineOnFiletype()
    let should_enable = &filetype != 'javascript'
    if s:tagbar_enabled != should_enable
        let s:tagbar_enabled = should_enable
        silent! autocmd! TagbarAutoCmds
        call AirlineInit()
        AirlineRefresh
    endif
endf

augroup airline_tagbar_handler
    autocmd!
    autocmd filetype * call s:ToggleAirlineOnFiletype()
augroup end

" Gutentags
let g:gutentags_exclude = ['node_modules', '.git']

" YouCompleteMe
nnoremap <leader>ycm :let g:ycm_auto_trigger = !g:ycm_auto_trigger<cr>
nnoremap <leader>gtd :YcmCompleter GoTo<cr>
nnoremap <leader>gtr :YcmCompleter GoToReferences<cr>:cclose<cr>:copen<cr>
nnoremap <leader>gtk :YcmCompleter GetDoc<cr>
nnoremap <leader>gtt :YcmCompleter GetType<cr>
nnoremap <leader>rv :YcmCompleter RefactorRename<space>
nnoremap <leader>q :pclose<cr>:cclose<cr>:lclose<cr>

let g:ycm_path_to_python_interpreter                    = '/usr/bin/python2.7'
let g:ycm_key_list_select_completion                    = ['<Down>']
let g:ycm_key_list_previous_completion                  = ['<Up>']
let g:ycm_complete_in_comments                          = 1
let g:ycm_complete_in_strings                           = 1
let g:ycm_collect_identifiers_from_comments_and_strings = 1
let g:ycm_collect_identifiers_from_tags_files           = 1

" UltiSnips

let g:ulti_expand_res = 0
let g:ulti_jump_forwards_res = 0
function! JumpOrExpandSnippet()
    call UltiSnips#JumpForwards()
    if !g:ulti_jump_forwards_res
        call UltiSnips#ExpandSnippet()
    endif
    return ''
endfunction

function! MyExpandSnippet()
    call UltiSnips#ExpandSnippet()
    return ''
endf

let g:UltiSnipsEditSplit           = "vertical"
xnoremap <silent> <tab> :call UltiSnips#SaveLastVisualSelection()<CR>gvs
inoremap <silent> <c-j> <c-r>=JumpOrExpandSnippet()<cr>
imap <silent> <Tab> <c-r>=MyExpandSnippet()<cr>[should]jump
inoremap <silent><expr> [should]jump g:ulti_expand_res ? '' : (pumvisible() ? "\<c-n>" : "\<tab>")
let g:UltiSnipsExpandTrigger       = "<leader><localleader><tab>"
let g:UltiSnipsJumpBackwardTrigger = "<c-k>"
let g:UltiSnipsListSnippets        = "<c-l>"
let g:UltiSnipsSnippetsDir         = '~/.snips'
let g:UltiSnipsSnippetDirectories  = ["UltiSnips", $HOME . "/.snips"]
inoremap <c-x><c-k> <c-x><c-k>
nmap <leader>esp :UltiSnipsEdit<cr>

" ToggleList
let g:toggle_list_no_mappings = 1

" NerdTREE
let NERDTreeIgnore=['\.pyc$']
nnoremap <leader>ff :NERDTreeFind<cr>

" Ruby
let g:rubycomplete_buffer_loading = 1
let g:rubycomplete_classes_in_global = 1
let g:rubycomplete_use_bundler = 1
let g:rubycomplete_load_gemfile = 1

" Vimux
let VimuxResetSequence = "q q C-u"
" Prompt for a command to run
map <localleader>vp :VimuxPromptCommand<CR>
" Run last command executed by VimuxRunCommand
map <localleader>vl :call VimuxSendKeys('up Enter')<CR>
" Inspect runner pane
map <localleader>vi :VimuxInspectRunner<CR>
" Close vim tmux runner opened by VimuxRunCommand
map <localleader>vq :VimuxCloseRunner<CR>
" Interrupt any command running in the runner pane
map <localleader>vx :VimuxInterruptRunner<CR>
" Zoom the runner pane (use <bind-key> z to restore runner pane)
map <localleader>vz :call VimuxZoomRunner()<CR>
" Open Vimux Page if it's closed
map <localleader>vo :call VimuxOpenRunner()<CR>

function! VimuxSlime() range
    call VimuxRunCommand(s:get_visual_selection())
endfunction

function! VimuxSlimeLineBreak() range
    call VimuxSlime()
    call VimuxSendKeys('Enter')
endfunction

function! VimuxSlimeSemicolon() range
    call VimuxRunCommand(s:get_visual_selection() . '\;')
endfunction

function! VimuxCopyPostres() range
    call VimuxRunCommand('\COPY (' . s:get_visual_selection() . ") TO PROGRAM 'pbcopy' DELIMITER e'\\t' CSV HEADER\;")
endfunction

function! GetExecuteCommand()
    let filetype_to_command = {
                \   'javascript': 'node',
                \   'coffee': 'coffee',
                \   'python': 'python',
                \   'html': 'open',
                \   'ruby': 'ruby',
                \   'sh': 'sh'
                \ }
    let cmd = get(filetype_to_command, &filetype, &filetype)
    return cmd . " " . expand("%")
endfunction

function! GetNodemonCommand()
    let filetype_to_extension = {
                \   'javascript': 'js',
                \   'coffee': 'coffee',
                \   'python': 'py',
                \   'ruby': 'rb'
                \ }
    let extension = get(filetype_to_extension, &filetype, &filetype)
    let cmd = GetExecuteCommand()
    return  'nodemon -L -e "' . extension . '" -x "' . cmd . '"'
endfunction

function! GetReplCommand()
    let filetype_to_repl = {
                \   'javascript': 'node',
                \   'ruby': 'rbenv exec pry',
                \   'sql': 'pagarme_postgres'
                \ }
    let repl_bin = get(filetype_to_repl, &filetype, &filetype)
    echo repl_bin
    return  repl_bin
endfunction

" If text is selected, save it in the v buffer and send that buffer it to tmux
vmap <localleader>vs :call VimuxSlime()<CR>`>j^
vmap <localleader>vj Jgv:call VimuxSlime()<CR>u`>j^
vmap <localleader>vyp Jgv:call VimuxCopyPostres()<CR>u`>j^
vmap <localleader>v; Jgv:call VimuxSlimeSemicolon()<CR>u`>j^
vmap <localleader><CR> <localleader>vs

" Select current paragraph and send it to tmux
nmap <localleader>vs vip<localleader>vs
nmap <localleader>vj vip<localleader>vj
nmap <localleader>vyp vip<localleader>vyp
nmap <localleader>v; vip<localleader>v;
nmap <localleader><CR> V<localleader>vs
nmap <localleader>va ggVG<localleader>vs

" Python specific shortcuts
augroup python-vimux-shortuts
    autocmd!
    autocmd FileType python vmap <buffer> <localleader>vs :call VimuxSlimeLineBreak()<CR>`>j^
    autocmd FileType python nmap <localleader><CR> V:call VimuxSlime()<CR>`>j^
augroup END

" Execute current file in the interpreter
nnoremap <localleader>vf :w<CR>:call VimuxRunCommand(GetExecuteCommand())<CR>
nnoremap <localleader>vw :call VimuxRunCommand(GetNodemonCommand())<CR>
nmap <localleader>vr <localleader>vq:call VimuxRunCommand(GetReplCommand())<CR>
nnoremap <localleader>vtp :call VimuxRunCommand('exec-notify ./script/test ' . expand('%'))<cr>

" Ctrlp
let g:ctrlp_custom_ignore = '\v([\/]\.(git|hg|svn)$)|\.pyc$|node_modules/'

" Localvimrc
let g:localvimrc_persistent = 1
let g:avoid_standard_js_autowriter = 1
let g:localvimrc_event = ['VimEnter']

" Autoformat
noremap <leader>sb :Autoformat<cr>
let g:formatdef_sqlformat = '"sqlformat -k upper -r --indent_width=4 -"'
let g:formatdef_rubocop = '"rubocop --auto-correct " . expand("%") . " -o /dev/null || cat " . expand("%")'
let g:formatdef_standardjs = '"standard-format -"'
let g:formatters_sql = ['sqlformat']
let g:formatters_ruby = ['rubocop']

" Autoft
let g:autoft_config = [
            \ { 'filetype': 'html' , 'pattern': '<\%(!DOCTYPE\|html\|head\|script\)' },
            \ { 'filetype': 'c'    , 'pattern': '^\s*#\s*\%(include\|define\)\>' },
            \ { 'filetype': 'diff' , 'pattern': '^diff -' },
            \ { 'filetype': 'sh'   , 'pattern': '^#!.*\%(\<sh\>\|\<bash\>\)\s*$' },
            \ { 'filetype': 'sql'  , 'pattern': '^\s*SELECT.*$' },
            \ ]

" GUndo
nnoremap <leader>gu :GundoToggle<CR>

" Winresizer
let g:winresizer_start_key = '<leader>wr'
let g:winresizer_keycode_left = 72
let g:winresizer_keycode_right = 76
let g:winresizer_keycode_down = 74
let g:winresizer_keycode_up = 75
nmap <leader>H <leader>wrH
nmap <leader>J <leader>wrJ
nmap <leader>K <leader>wrK
nmap <leader>L <leader>wrL

" Tabularize
noremap <leader>ta :Tabularize /

" SQLComplete
function! MyOwnSqlComplete(findstart, base)
    if a:findstart
        return sqlcomplete#Complete(a:findstart, a:base)
    else
        " find months matching with "a:base"
        let original = sqlcomplete#Complete(a:findstart, a:base)
        let res = []
        for m in original
            let cur = m
            let pattern = '\C\([a-z]\+\).\(\([A-Z][a-z]*\)\+\)'
            if cur =~ pattern
                let cur = substitute(cur, pattern, '\1."\2"', '')
            endif
            call add(res, cur)
        endfor
        return res
    endif
endfun

augroup my-sql-complete
    autocmd!
    autocmd FileType sql set omnifunc=MyOwnSqlComplete
augroup END

" Vim Signify
let g:signify_update_on_focusgained = 1
let g:signify_update_on_bufenter = 1

" R specific
augroup R-specific-settings
    au!
    au FileType R,rmd let b:delimitMate_matchpairs = "(:),[:],{:}"
augroup END

" Textobj User

call textobj#user#plugin('javascriptchunck', {
            \   '-': {
            \     'select-a-function': 'JavaScriptChuncklock',
            \     'select-a': 'aj',
            \     'select-i-function': 'JavaScriptChuncklock',
            \     'select-i': 'ij',
            \   },
            \ })

function! JavaScriptChuncklock()
    normal! ^va{`>$
    let tail_pos = getpos('.')
    normal! `<^
    let head_pos = getpos('.')
    if tail_pos == head_pos
        return 0
    endif
    return ['v', head_pos, tail_pos]
endfunction

let g:textobj_python_no_default_key_mappings = 1

call textobj#user#map('python', {
            \   'class': {
            \     'select-a': '<buffer>aP',
            \     'select-i': '<buffer>iP',
            \   },
            \ })

let g:textobj#methodcall#select_a = 'am'
let g:textobj#methodcall#select_i = 'im'

" Tcommenter
let g:tcommentTextObjectInlineComment = ''

" Unite.vim

call unite#custom#source('grep, line', 'matchers', 'matcher_fuzzy')
call unite#custom#source('grep, line', 'sorters', 'sorter_rank')
call unite#filters#matcher_default#use(['matcher_fuzzy'])
call unite#filters#sorter_default#use(['sorter_rank'])

" Using ag as recursive command.
let g:unite_source_rec_async_command = ['ag', '--follow', '--nocolor', '--nogroup', '--hidden', '-g', '']
let g:unite_source_grep_command = 'ag'
let g:unite_source_grep_default_opts = '-i --vimgrep --hidden --ignore ' .
            \ '''.hg'' --ignore ''.svn'' --ignore ''.git'' --ignore ''.bzr'''
let g:unite_source_grep_recursive_opt = ''

" Yank history mappings
nnoremap <leader>< :<c-u>Unite history/yank -default-action=append -no-start-insert<CR>
vmap <leader>< d:<c-u>Unite history/yank<CR>

" Quickly switch buffers
nnoremap <leader>bb :Unite -quick-match buffer<cr>

" Cmd completion
cm <c-o> <Plug>(unite_cmdmatch_complete)

" Localvimrc
nmap <leader>epv :<c-u>Unite -input=.lvimrc file_rec/neovim<cr>
nmap <leader>spv :<c-u>LocalVimRC<cr>

" The prefix key.
nnoremap [unite] <Nop>
nmap s [unite]

nnoremap <silent> [unite]r :<C-u>UniteResume<CR>
nnoremap <silent> [unite]ma :<C-u>Unite mapping<CR>
nnoremap <silent> [unite]me :<C-u>Unite output:message<CR>
nnoremap <silent> [unite]u :<C-u>Unite ultisnips<CR>
nnoremap <silent> [unite]tt :<c-u>Unite tmuxcomplete -default-action=append<cr>
nnoremap <silent> [unite]tl :<c-u>Unite tmuxcomplete/lines -default-action=append<cr>
nnoremap <silent> [unite]l :<c-u>Unite line<cr>
nnoremap <silent> [unite]l :<c-u>Unite line<cr>

nnoremap <silent> [unite]f
            \ :<C-u>Unite -buffer-name=files jump_point file_point buffer_tab file_rec/neovim:! file file/new<CR>

" Like ctrlp.vim settings.
call unite#custom#profile('default', 'context', {
            \   'start_insert': 1,
            \   'winheight': 10,
            \   'direction': 'botright',
            \ })

autocmd FileType unite call s:unite_my_settings()
function! s:unite_my_settings()
    nmap <buffer> <C-z> <Plug>(unite_toggle_transpose_window)
    imap <buffer> <C-z> <Plug>(unite_toggle_transpose_window)
    nmap <buffer> <C-j> <Plug>(unite_toggle_auto_preview)
    imap <buffer> <C-j> <Plug>(unite_toggle_auto_preview)
    nmap <buffer> <C-r> <Plug>(unite_narrowing_input_history)
    imap <buffer> <C-r> <Plug>(unite_narrowing_input_history)
    nmap <buffer> <C-@> <Plug>(unite_complete)
    imap <buffer> <C-@> <Plug>(unite_complete)
    nmap <buffer> <esc> <Plug>(unite_exit)
    nmap <buffer><expr> v unite#do_action('left')
    imap <buffer><expr> <c-v> unite#do_action('left')
endfunction

" Indent guides for Neovim
let g:indent_guides_auto_colors = 0
hi IndentGuidesOdd  guibg=black ctermbg=0
hi IndentGuidesEven guibg=white ctermbg=7

" Neomake
augroup neomake_save_linter
    autocmd!
    autocmd BufWritePost *.js Neomake
    autocmd BufWritePost *.py Neomake
    autocmd BufWritePost *.rb Neomake
augroup end
let g:neomake_javascript_standard_maker = { 'errorformat': '%E %f:%l:%c: %m' }

" Textobj column
let g:skip_default_textobj_word_column_mappings = 1

xnoremap <silent> ak :<C-u>call TextObjWordBasedColumn("aw")<cr>
xnoremap <silent> aK :<C-u>call TextObjWordBasedColumn("aW")<cr>
xnoremap <silent> ik :<C-u>call TextObjWordBasedColumn("iw")<cr>
xnoremap <silent> iK :<C-u>call TextObjWordBasedColumn("iW")<cr>
onoremap <silent> ak :call TextObjWordBasedColumn("aw")<cr>
onoremap <silent> aK :call TextObjWordBasedColumn("aW")<cr>
onoremap <silent> ik :call TextObjWordBasedColumn("iw")<cr>
onoremap <silent> iK :call TextObjWordBasedColumn("iW")<cr>

" Vim autoswap
let g:autoswap_detect_tmux = 1

" Delimitmate
imap <expr> <c-x><c-l> ( delimitMate#ShouldJump() ? "<Plug>delimitMateS-BS" : "") . "\<c-x>\<c-l>"
let g:delimitMate_expand_space = 1
let g:delimitMate_jump_expansion = 1
let g:delimitMate_expand_cr = 1
