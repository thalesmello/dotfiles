" # Local settings {{{
let maplocalleader = "'"
set cursorline
set nojoinspaces
set wildmode=list:longest,full
set listchars=tab:▸\ ,eol:¬
set lazyredraw
set completeopt-=preview
set linebreak
set noshowmode
set updatetime=500
let $NVIM_TUI_ENABLE_CURSOR_SHAPE=1
if has('nvim')
    set termguicolors
endif

" Don't wait for ESC to timeout
set timeoutlen=1000 ttimeoutlen=0
" }}}"
" # Mappings  {{{
vnoremap <c-c> "+y
nnoremap <leader>o `>
nnoremap <leader>ss :w<cr>
nnoremap <leader>saa ggVG
nnoremap <leader>sy :setfiletype<space>
nnoremap <leader>saq ?\v('''\|""")<CR>vw//e<CR>
nnoremap <leader>siq ?\v('''\|""")<CR>wv//e<CR>ge
nmap <leader>tb :TagbarToggle<CR>
nmap <leader>/ *N
vmap <leader>/ *N
vmap <leader>c/ *Ncgn
nmap <leader>c/ *Ncgn
inoremap <c-u> <c-g>u<c-u>
nnoremap Y y$
nnoremap <leader>fw :FixWhitespace<cr>
vmap <leader>yj Jgvyu
nmap <leader>tn :tabnew<cr>
vmap <leader>tn y:tabnew<cr>p
nmap <leader>bn :vnew<cr>
vmap <leader>bn y:vnew<cr>p
nmap <leader>bc :bw<cr>
nnoremap <leader>bs :Sscratch<cr>
vmap <leader>bs y:Sscratch<cr>vaep
noremap <c-e> 2<c-e>
noremap <c-y> 2<c-y>
noremap gH H
noremap gL L
nnoremap <leader>; A;<esc>
nnoremap <leader><bs> $x<esc>
nnoremap <leader>= <c-w>=
nnoremap <S-ScrollWheelUp>   <ScrollWheelLeft>
nnoremap <S-2-ScrollWheelUp> <2-ScrollWheelLeft>
nnoremap <S-3-ScrollWheelUp> <3-ScrollWheelLeft>
nnoremap <S-4-ScrollWheelUp> <4-ScrollWheelLeft>
nnoremap <S-ScrollWheelDown>     <ScrollWheelRight>
nnoremap <S-2-ScrollWheelDown>   <2-ScrollWheelRight>
nnoremap <S-3-ScrollWheelDown>   <3-ScrollWheelRight>
nnoremap <S-4-ScrollWheelDown>   <4-ScrollWheelRight>
nnoremap <silent> <leader>q :pclose<cr>:cclose<cr>:lclose<cr>:UniteClose<cr>

command! YankShouldToExpectRegex let @s = "\\v\\s+\\zs((\\w|\\.|\\[|\\]|'|\")+)\\.should/expect(\\1).to"
command! YankStatusToPropertyCheck let @s = '\vhave\.status\((\d+)\)/have.property(' . "'statusCode', \\1)"

" "}}}
" # Pulse Cursor  {{{
function! s:PulseCursor()
    let cursorline_opt = &cursorline
    let cursorcolumn_opt = &cursorcolumn
    setlocal nocursorline
    redraw
    sleep 50m
    setlocal cursorline
    setlocal cursorcolumn
    redraw
    sleep 50m
    setlocal nocursorcolumn
    setlocal nocursorline
    redraw
    sleep 50m
    setlocal cursorcolumn
    setlocal cursorline
    redraw
    sleep 50m
    setlocal nocursorcolumn
    redraw
endfunction

augroup pulse_cursor_on_focus
    autocmd!
    autocmd FocusGained * call s:PulseCursor()
augroup end

nnoremap <leader>pc :call <SID>PulseCursor()<cr>
" "}}}
" # Vim over  {{{
nnoremap  gs  :OverCommandLine<cr>%s//g<LEFT><LEFT>
vnoremap  gs  :OverCommandLine<cr>s//g<LEFT><LEFT>
let g:over_enable_auto_nohlsearch = 0

" "}}}
" # Dein  {{{
command! DeinClean call map(dein#check_clean(), "system('rm -rf ' . v:val)")
command! DeinRecache call dein#recache_runtimepath()

" "}}}
" # Move around text objects  {{{
nnoremap <localleader>s :exec "normal vi".nr2char(getchar())."\e`<"<CR>
nnoremap <localleader>e :exec "normal vi".nr2char(getchar())."\e`>"<CR>
nnoremap <localleader>S :exec "normal va".nr2char(getchar())."\e`<"<CR>
nnoremap <localleader>E :exec "normal va".nr2char(getchar())."\e`>"<CR>

" "}}}
" # Tmux complete  {{{
let g:tmuxcomplete#capture_args = '-J -S -'

" "}}}
" # Vim Multiple Cursors  {{{
let g:multi_cursor_exit_from_insert_mode = 0
let g:multi_cursor_exit_from_visual_mode = 0
function! Multiple_cursors_before()
    let s:old_disable_deoplete = g:deoplete#disable_auto_complete
    let g:deoplete#disable_auto_complete = 1
endfunction

function! Multiple_cursors_after()
    let g:deoplete#disable_auto_complete = s:old_disable_deoplete
endfunction

nmap <c-n> :call multiple_cursors#new("n", 1)<CR>
noremap g<c-n> :MultipleCursorsFind <c-r>/<cr>

highlight multiple_cursors_cursor term=reverse cterm=reverse gui=reverse
highlight link multiple_cursors_visual Visual

" "}}}
" # Tagbar  {{{
let g:tagbar_left = 1
let g:tagbar_autoclose = 1
let g:tagbar_autofocus = 1

" "}}}
" # Sneak  {{{
nnoremap s s
nmap f <Plug>(SneakStreak)
nmap F <Plug>(SneakStreakBackward)
xmap f <Plug>(SneakStreak)
xmap F <Plug>(SneakStreakBackward)
omap f <Plug>(SneakStreak)
omap F <Plug>(SneakStreakBackward)
let g:sneak#use_ic_scs = 1
let g:sneak#target_labels = "sfghjkl;qwertyuiopzxvbnm/SFGHJKL:QWERTYUOPZXCVBNM?"
let g:sneak#textobject_z = 0

" "}}}
" # Vim Tmux Navigator  {{{
let g:tmux_navigator_no_mappings = 1
nnoremap <silent> <C-H> :TmuxNavigateLeft<cr>
nnoremap <silent> <C-J> :TmuxNavigateDown<cr>
nnoremap <silent> <C-K> :TmuxNavigateUp<cr>
nnoremap <silent> <C-L> :TmuxNavigateRight<cr>
nnoremap <silent> <C-\> :TmuxNavigatePrevious<cr>

" "}}}
" # Devdocs  {{{
augroup plugin_devdocs
    autocmd!
    autocmd FileType c,cpp,rust,haskell,python,javascript,html,eruby,ruby nmap <buffer>K <Plug>(devdocs-under-cursor)
    autocmd FileType c,cpp,rust,haskell,python,javascript,html,eruby,ruby vmap <buffer>K y:DevDocs <C-R>"<CR>
    autocmd FileType * nmap <buffer>gK <Plug>(devdocs-under-cursor-all)
    autocmd FileType * vmap <buffer><silent>gK y:DevDocsAll <C-R>"<CR>
augroup END
let g:devdocs_filetype_map = {
            \   'ruby': 'ruby',
            \ }

" "}}}
" # Semantic highlighting  {{{
let g:semanticTermColors = [28,1,2,3,87,5,6,7,81,9,10,34,11,13,14,15,165,154,49,139]
nnoremap <Leader>sh :SemanticHighlightToggle<cr>

" "}}}
" # Pipe visual to shell {{{
" By Xolox @ http://stackoverflow.com/questions/1533565/how-to-get-visually-selected-text-in-vimscript
function! s:get_visual_selection()
    let [lnum1, col1] = getpos("'<")[1:2]
    let [lnum2, col2] = getpos("'>")[1:2]
    let lines = getline(lnum1, lnum2)
    let lines[-1] = lines[-1][: col2 - (&selection == 'inclusive' ? 1 : 2)]
    let lines[0] = lines[0][col1 - 1:]
    return join(lines, "\n")
endfunction

function! s:Chomp(string)
    return substitute(a:string, '\n\+$', '', '')
endfunction

function! s:visual_command() range
    let text = s:get_visual_selection()
    let cmd = input('Pipe: ', '', 'shellcmd')
    let @v = s:Chomp(system(cmd, text))
    execute 'normal! gv"vp'
endfunction

command! -range VisualCommand <line1>,<line2>call s:visual_command()
vnoremap <leader>\| :VisualCommand<CR>

" }}} "
" # Airline  {{{
let g:airline_powerline_fonts = 1
let g:airline_theme = 'powerlineish'
let g:airline_inactive_collapse = 1
let g:airline#extensions#disable_rtp_load = 1
let g:airline_extensions = ['neomake', 'tagbar', 'branch', 'tabline', 'unite']
let g:airline#extensions#tagbar#flags = 'f'
let g:airline#extensions#branch#displayed_head_limit = 15
let g:airline#extensions#default#section_truncate_width = {}

let s:tagbar_enabled = 1

function! AirlineInit()
    let g:airline_section_a = airline#section#create(['mode'])
    let g:airline_section_b = airline#section#create(['file', ' ', 'readonly'])
    if s:tagbar_enabled
        let g:airline_section_c = airline#section#create(['tagbar'])
    else
        let g:airline_section_c = airline#section#create([])
    endif
    let g:airline_section_x = airline#section#create([])
    let g:airline_section_y = airline#section#create(['%<', 'branch'])
    let g:airline_section_z = airline#section#create(['%p%% ', '%{g:airline_symbols.linenr}%#__accent_bold#%l%#__restore__#:%v'])
endfunction
autocmd User AirlineAfterInit call AirlineInit()

fun! s:ToggleAirlineOnFiletype()
    let should_enable = &filetype != 'javascript'
    if s:tagbar_enabled != should_enable
        let s:tagbar_enabled = should_enable
        silent! autocmd! TagbarAutoCmds
        call AirlineInit()
        AirlineRefresh
    endif
endf

augroup airline_tagbar_handler
    autocmd!
    autocmd filetype * call s:ToggleAirlineOnFiletype()
augroup end

" "}}}
" # Gutentags  {{{
let g:gutentags_exclude = ['node_modules', '.git']

" "}}}
" # Deoplete  {{{
let g:deoplete#enable_at_startup = 1
let g:echodoc_enable_at_startup = 1

function! ToggleEchoDocFunc()
    if echodoc#is_enabled()
        call echodoc#disable()
    else
        call echodoc#enable()
    endif
endfunction

command! EchoDocToggle call ToggleEchoDocFunc()
nnoremap <leader>ed :<c-u>EchoDocToggle<cr>

inoremap <up> <c-p>
inoremap <down> <c-n>

" "}}}
" # UltiSnips  {{{
let g:ulti_expand_res = 0
let g:ulti_jump_forwards_res = 0
function! JumpOrExpandSnippet()
    call UltiSnips#JumpForwards()
    if !g:ulti_jump_forwards_res
        call UltiSnips#ExpandSnippet()
    endif
    return ''
endfunction

function! MyExpandSnippet()
    call UltiSnips#ExpandSnippet()
    return ''
endf

let g:UltiSnipsEditSplit           = "vertical"
xnoremap <silent> <tab> :call UltiSnips#SaveLastVisualSelection()<CR>gvs
inoremap <silent> <c-j> <c-r>=JumpOrExpandSnippet()<cr>
imap <silent> <Tab> <c-r>=MyExpandSnippet()<cr>[should]jump
inoremap <silent><expr> [should]jump g:ulti_expand_res ? '' : (pumvisible() ? "\<c-n>" : "\<tab>")
let g:UltiSnipsExpandTrigger       = "<c-t><c-t><c-t>"
let g:UltiSnipsJumpBackwardTrigger = "<c-k>"
let g:UltiSnipsSnippetsDir         = '~/.snips'
let g:UltiSnipsSnippetDirectories  = ["UltiSnips", $HOME . "/.snips"]
inoremap <c-x><c-k> <c-x><c-k>
nmap <leader>esp :UltiSnipsEdit<cr>

inoremap <silent> <c-l> <esc>:<c-u>Unite ultisnips -start-insert<cr>

" "}}}
" # ToggleList  {{{
let g:toggle_list_no_mappings = 1

" "}}}
" # NerdTREE  {{{
let NERDTreeIgnore=['\.pyc$']
nnoremap <leader>ff :NERDTreeFind<cr>

" "}}}
" # Ruby  {{{
let g:rubycomplete_buffer_loading = 1
let g:rubycomplete_classes_in_global = 1
let g:rubycomplete_use_bundler = 1
let g:rubycomplete_load_gemfile = 1

" "}}}
" # Vimux  {{{
let VimuxResetSequence = "q q i C-u"
" Prompt for a command to run
map <silent> <localleader>vp :VimuxPromptCommand<CR>
" Run last command executed by VimuxRunCommand
map <silent> <localleader>vl :call VimuxSendKeys('up Enter')<CR>
" Inspect runner pane
map <silent> <localleader>vi :VimuxInspectRunner<CR>
" Close vim tmux runner opened by VimuxRunCommand
map <silent> <localleader>vq :VimuxCloseRunner<CR>
" Interrupt any command running in the runner pane
map <silent> <localleader>vx :VimuxInterruptRunner<CR>
" Zoom the runner pane (use <bind-key> z to restore runner pane)
map <silent> <localleader>vz :call VimuxZoomRunner()<CR>
" Open Vimux Page if it's closed
map <silent> <localleader>vo :call VimuxOpenRunner()<CR>

function! VimuxSlime() range
    call VimuxRunCommand(s:get_visual_selection())
endfunction

function! VimuxSlimeLineBreak() range
    call VimuxSlime()
    call VimuxSendKeys('Enter')
endfunction

function! VimuxSlimeSemicolon() range
    call VimuxRunCommand(s:get_visual_selection() . '\;')
endfunction

function! VimuxCopyPostres() range
    call VimuxRunCommand('\COPY (' . s:get_visual_selection() . ") TO PROGRAM 'pbcopy' DELIMITER e'\\t' CSV HEADER\;")
endfunction

function! GetExecuteCommand()
    let filetype_to_command = {
                \   'javascript': 'node',
                \   'coffee': 'coffee',
                \   'python': 'python',
                \   'html': 'open',
                \   'ruby': 'ruby',
                \   'sh': 'sh'
                \ }
    let cmd = get(filetype_to_command, &filetype, &filetype)
    return cmd . " " . expand("%")
endfunction

function! GetNodemonCommand()
    let filetype_to_extension = {
                \   'javascript': 'js',
                \   'coffee': 'coffee',
                \   'python': 'py',
                \   'ruby': 'rb'
                \ }
    let extension = get(filetype_to_extension, &filetype, &filetype)
    let cmd = GetExecuteCommand()
    return  'nodemon -L -e "' . extension . '" -x "' . cmd . '"'
endfunction

function! GetReplCommand()
    let filetype_to_repl = {
                \   'javascript': 'node',
                \   'ruby': 'rbenv exec pry',
                \   'sql': 'pagarme_postgres'
                \ }
    let repl_bin = get(filetype_to_repl, &filetype, &filetype)
    echo repl_bin
    return  repl_bin
endfunction

" If text is selected, save it in the v buffer and send that buffer it to tmux
vmap <silent> <localleader>vs :call VimuxSlime()<CR>`>j^
vmap <silent> <localleader>vj Jgv:call VimuxSlime()<CR>u`>j^
vmap <silent> <localleader>vyp Jgv:call VimuxCopyPostres()<CR>u`>j^
vmap <silent> <localleader>v; Jgv:call VimuxSlimeSemicolon()<CR>u`>j^
vmap <silent> <localleader><CR> <localleader>vs

" Select current paragraph and send it to tmux
nmap <silent> <localleader>vs vip<localleader>vs
nmap <silent> <localleader>vj vip<localleader>vj
nmap <silent> <localleader>vyp vip<localleader>vyp
nmap <silent> <localleader>v; vip<localleader>v;
nmap <silent> <localleader><CR> V<localleader>vs
nmap <silent> <localleader>vaa ggVG<localleader>vs
nmap <silent> <localleader>vaj ggVG<localleader>vj

" Python specific shortcuts
augroup python_vimux_shortuts
    autocmd!
    autocmd FileType python vmap <buffer> <localleader>vs :call VimuxSlimeLineBreak()<CR>`>j^
    autocmd FileType python nmap <localleader><CR> V:call VimuxSlime()<CR>`>j^
augroup END

" Execute current file in the interpreter
nnoremap <silent> <localleader>vf :w<CR>:call VimuxRunCommand(GetExecuteCommand())<CR>
nnoremap <silent> <localleader>vw :call VimuxRunCommand(GetNodemonCommand())<CR>
nmap <silent> <localleader>vr <localleader>vq:call VimuxRunCommand(GetReplCommand())<CR>
nnoremap <silent> <localleader>vtp :call VimuxRunCommand('exec-notify ./script/test ' . expand('%'))<cr>

" "}}}
" # Localvimrc  {{{
let g:localvimrc_persistent = 1
let g:avoid_standard_js_autowriter = 1
let g:localvimrc_event = ['VimEnter']

" "}}}
" # Autoformat  {{{
noremap <leader>sb :Autoformat<cr>
let g:formatdef_sqlformat = '"sqlformat -k upper -r --indent_width=4 -"'
let g:formatdef_rubocop = '"rubocop --auto-correct " . expand("%") . " -o /dev/null || cat " . expand("%")'
let g:formatdef_standardjs = '"standard-format -"'
let g:formatters_sql = ['sqlformat']
let g:formatters_ruby = ['rubocop']

" "}}}
" # GUndo  {{{
nnoremap <leader>gu :MundoToggle<CR>

" "}}}
" # Winresizer  {{{
let g:winresizer_start_key = '<leader>wr'
let g:winresizer_keycode_left = 72
let g:winresizer_keycode_right = 76
let g:winresizer_keycode_down = 74
let g:winresizer_keycode_up = 75
nmap <leader>H <leader>wrH
nmap <leader>J <leader>wrJ
nmap <leader>K <leader>wrK
nmap <leader>L <leader>wrL

" "}}}
" # Tabularize  {{{
noremap <leader>ta :Tabularize /
noremap <leader>t/ :Tabularize /<c-r>/<cr>

" "}}}
" # SQLComplete  {{{
function! MyOwnSqlComplete(findstart, base)
    if a:findstart
        return sqlcomplete#Complete(a:findstart, a:base)
    else
        " find months matching with "a:base"
        let original = sqlcomplete#Complete(a:findstart, a:base)
        let res = []
        for m in original
            let cur = m
            let pattern = '\C\([a-z]\+\).\(\([A-Z][a-z]*\)\+\)'
            if cur =~ pattern
                let cur = substitute(cur, pattern, '\1."\2"', '')
            endif
            call add(res, cur)
        endfor
        return res
    endif
endfun

augroup my_sql_complete
    autocmd!
    autocmd FileType sql set omnifunc=MyOwnSqlComplete
augroup END

" "}}}
" # Vim Signify  {{{
let g:signify_update_on_focusgained = 1
let g:signify_update_on_bufenter = 1

" "}}}
" # R specific  {{{
augroup R_specific_settings
    au!
    au FileType R,rmd let b:delimitMate_matchpairs = "(:),[:],{:}"
augroup END

" "}}}
" # Textobj User  {{{
call textobj#user#plugin('javascriptchunck', {
            \   '-': {
            \     'select-a-function': 'JavaScriptChuncklock',
            \     'select-a': 'aj',
            \     'select-i-function': 'JavaScriptChuncklock',
            \     'select-i': 'ij',
            \   },
            \ })

function! JavaScriptChuncklock()
    normal! ^va{`>$
    let tail_pos = getpos('.')
    normal! `<^
    let head_pos = getpos('.')
    if tail_pos == head_pos
        return 0
    endif
    return ['v', head_pos, tail_pos]
endfunction

let g:textobj_python_no_default_key_mappings = 1

call textobj#user#map('python', {
            \   'class': {
            \     'select-a': '<buffer>aP',
            \     'select-i': '<buffer>iP',
            \   },
            \ })

let g:textobj#methodcall#select_a = 'am'
let g:textobj#methodcall#select_i = 'im'

" "}}}
" # Textobj column  {{{
let g:skip_default_textobj_word_column_mappings = 1
xnoremap <silent> ak :<C-u>call TextObjWordBasedColumn("aw")<cr>
xnoremap <silent> aK :<C-u>call TextObjWordBasedColumn("aW")<cr>
xnoremap <silent> ik :<C-u>call TextObjWordBasedColumn("iw")<cr>
xnoremap <silent> iK :<C-u>call TextObjWordBasedColumn("iW")<cr>
onoremap <silent> ak :call TextObjWordBasedColumn("aw")<cr>
onoremap <silent> aK :call TextObjWordBasedColumn("aW")<cr>
onoremap <silent> ik :call TextObjWordBasedColumn("iw")<cr>
onoremap <silent> iK :call TextObjWordBasedColumn("iW")<cr>

" "}}}
" # Tcommenter  {{{
let g:tcommentTextObjectInlineComment = ''

" "}}}
" # Unite.vim {{{
" Set default matcher options
call unite#custom#source('grep, line, outline', 'matchers', 'matcher_fuzzy')
call unite#custom#source('grep', 'sorters', 'sorter_rank')
call unite#custom#source('location_list, quickfix', 'sorters', 'sorter_nothing')
call unite#filters#matcher_default#use(['matcher_fuzzy'])
call unite#filters#sorter_default#use(['sorter_rank'])
call unite#custom#profile('default', 'context', {
    \   'start_insert': 0,
    \   'winheight': 15,
    \   'direction': 'topleft',
    \ })

" Using ag as recursive command.
let g:unite_source_rec_async_command = ['ag', '--follow', '--nocolor', '--nogroup', '--hidden', '-g', '']
let g:unite_source_grep_command = 'ag'
let g:unite_source_grep_default_opts = '-i --vimgrep --hidden --ignore ' .
            \ '''.hg'' --ignore ''.svn'' --ignore ''.git'' --ignore ''.bzr'''
let g:unite_source_grep_recursive_opt = ''
let g:unite_source_line_enable_highlight = 1
" Yank history mappings
nnoremap gp :<c-u>Unite history/yank -default-action=append<CR>
nnoremap gP :<c-u>Unite history/yank<CR>
vnoremap gp d:<c-u>call CallYankHistoryMaybeEnd()<cr>

function! IsAtEndOfLine()
    return col('.') == col('$') - 1 && col('.') != 1
endfunction

function! CallYankHistoryMaybeEnd()
    let action_to_take = IsAtEndOfLine() ? 'append' : 'insert'
    call unite#start(['history/yank'], { 'default_action': action_to_take })
endfunction

" Quickly switch buffers
nnoremap <leader>bb :Unite -quick-match buffer<cr>
" Cmd completion
cmap <c-@> <Plug>(unite_cmdmatch_complete)
" File explorer
nmap <silent> gf viwgf
if has('nvim')
    nnoremap <silent> <c-p> :<C-u>Unite -buffer-name=files file_rec/neovim:! file/new<CR>
    vnoremap <silent> gf "uy:<C-u>Unite -buffer-name=files file_rec/neovim:! -input=<c-r>u<CR>
else
    nnoremap <silent> <c-p> :<C-u>Unite -buffer-name=files file_rec/async:! file/new<CR>
    vnoremap <silent> gf "uy:<C-u>Unite -buffer-name=files file_rec/async:! -input=<c-r>u<CR>
endif
" Ack.vim
nnoremap <silent> <c-f> :<c-u>Unite grep:!<cr>
nnoremap <silent> <leader>a "uyiw:<c-u>Unite grep:!::<c-r>u<cr>
vnoremap <silent> <leader>a "uy:<c-u>Unite grep:!::<c-r>u<cr>


" Tmux completion unite settings
function! GetTmuxCompletion()
    let text = unite#get_cur_text()
    let text = substitute(text, '.\{-}\(\k*\)$', '\1', '')
    return unite#start_complete(['tmuxcomplete'], { 'start_insert' : 1, 'input' : text, 'default_action': 'append'})
endfunction
inoremap <silent><expr> <c-x><c-t> "\<c-g>u\<c-w>".GetTmuxCompletion()."\<right>"

" Localvimrc unite settings
nmap <leader>epv :<c-u>Unite -input=.lvimrc file_rec/neovim<cr>
nmap <leader>spv :<c-u>LocalVimRC<cr>

" Unite quickfix
let g:unite_quickfix_is_multiline=0
call unite#custom_source('quickfix', 'converters', 'converter_quickfix_highlight')
call unite#custom_source('location_list', 'converters', 'converter_quickfix_highlight')
nnoremap <silent> [unite]qf :<c-u>Unite -wrap -prompt-direction=top quickfix<cr>
nnoremap <silent> [unite]ll :<c-u>Unite -wrap -prompt-direction=top location_list<cr>

" Unimpaired like bindings
nnoremap <silent> [z :<c-u>UnitePrevious<cr>
nnoremap <silent> ]z :<c-u>UniteNext<cr>
nnoremap <silent> [Z :<c-u>UniteFirst<cr>
nnoremap <silent> ]Z :<c-u>UniteLast<cr>

" prefix key
nnoremap [unite] <Nop>
nmap s [unite]
nnoremap <silent> [unite]r :<C-u>UniteResume<CR>
nnoremap <silent> [unite]ma :<C-u>Unite mapping<CR>
nnoremap <silent> [unite]me :<C-u>Unite output:message<CR>
nnoremap <silent> [unite]u :<C-u>Unite ultisnips<CR>
nnoremap <silent> [unite]o :<C-u>Unite -direction=topleft -split outline<CR>
nnoremap <silent> [unite]tt :<c-u>Unite tmuxcomplete -default-action=append<cr>
nnoremap <silent> [unite]tl :<c-u>Unite tmuxcomplete/lines -default-action=append<cr>
nnoremap <silent> [unite]li :<c-u>Unite line<cr>
nnoremap <silent> [unite]f :<C-u>Unite file_mru<cr>

autocmd FileType unite call s:unite_my_settings()
function! s:unite_my_settings()
    nmap <buffer> <C-z> <Plug>(unite_toggle_transpose_window)
    imap <buffer> <C-z> <Plug>(unite_toggle_transpose_window)
    nmap <buffer> <C-j> <Plug>(unite_toggle_auto_preview)
    imap <buffer> <C-j> <Plug>(unite_toggle_auto_preview)
    nmap <buffer> <C-p> <Plug>(unite_narrowing_input_history)
    imap <buffer> <C-p> <Plug>(unite_narrowing_input_history)
    nmap <buffer> <C-r> <Plug>(unite_narrowing_input_history)
    imap <buffer> <C-r> <Plug>(unite_narrowing_input_history)
    nmap <buffer> <Tab> <Plug>(unite_complete)
    imap <buffer> <Tab> <Plug>(unite_complete)
    nmap <buffer> <C-@> <Plug>(unite_choose_action)
    imap <buffer> <C-@> <Plug>(unite_choose_action)
    nmap <buffer> <esc> <Plug>(unite_exit)
    nmap <buffer> / <Plug>(unite_insert_enter)
    nmap <buffer><expr> v unite#do_action('left')
    imap <buffer><expr> <c-v> unite#do_action('left')
endfunction
" " }}}
" # Unite Outline {{{
let g:unite_source_outline_highlight = {
\ 'comment' : 'Comment',
\ 'expanded': 'Constant',
\ 'function': 'Function',
\ 'id'      : 'Special',
\ 'macro'   : 'Macro',
\ 'method'  : 'Function',
\ 'normal'  : 'Normal',
\ 'package' : 'Normal',
\ 'special' : 'Macro',
\ 'type'    : 'Type',
\ 'level_1' : 'Type',
\ 'level_2' : 'PreProc',
\ 'level_3' : 'Identifier',
\ 'level_4' : 'Constant',
\ 'level_5' : 'Special',
\ 'level_6' : 'Normal',
\ 'parameter_list': 'Normal',
\ }
" "}}}
" # Indent guides configuration Neovim  {{{
let g:indent_guides_auto_colors = 0
hi IndentGuidesOdd  guibg=#353738 ctermbg=none
hi IndentGuidesEven guibg=#252627 ctermbg=black

" "}}}
" # Neomake  {{{
augroup neomake_save_linter
    autocmd!
    autocmd BufWritePost *.js Neomake
    autocmd BufWritePost *.py Neomake
    autocmd BufWritePost *.rb Neomake
augroup end
let g:neomake_javascript_standard_maker = { 'errorformat': '%E %f:%l:%c: %m' }

" "}}}
" # Vim autoswap  {{{
let g:autoswap_detect_tmux = 1

" "}}}
" # Delimitmate  {{{
imap <expr> <c-x><c-l> ( delimitMate#ShouldJump() ? "<Plug>delimitMateS-BS" : "") . "\<c-x>\<c-l>"
let g:delimitMate_expand_space = 1
let g:delimitMate_expand_cr = 1

if !exists('g:set_carriage_return')
    imap <CR> <C-G>u<Plug>delimitMateCR
    let g:set_carriage_return = 1
endif


" "}}}
" # Windowswap  {{{
let g:windowswap_map_keys = 0 "prevent default bindings
nnoremap <silent> <leader>pp :call WindowSwap#EasyWindowSwap()<CR>

" "}}}
" # Vimwiki  {{{
let g:vimwiki_list = [{'path': '~/Dropbox/Apps/vimwiki/wiki', 'path_html': '~/Dropbox/Apps/vimwiki/html'}]

" "}}}
" # Persistent undo  {{{
if has('persistent_undo')
    set undolevels=5000
    set undodir=$HOME/.VIM_UNDO_FILES
    set undofile
endif
set updatecount=10


" "}}}
" # Schlepp  {{{
if !exists('g:set_schlepp_shortcuts')
    vmap <unique> <up>    <Plug>SchleppUp
    vmap <unique> <down>  <Plug>SchleppDown
    vmap <unique> <left>  <Plug>SchleppLeft
    vmap <unique> <right> <Plug>SchleppRight
    vmap <unique> D       <Plug>SchleppDup
    let g:set_schlepp_shortcuts = 1
endif

" "}}}
" # incsearch.vim  {{{
map /  <Plug>(incsearch-forward)
map ?  <Plug>(incsearch-backward)
map g/ <Plug>(incsearch-stay)
" "}}}
