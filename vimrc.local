" # Local settings {{{
let maplocalleader = "'"
set cursorline
set listchars=tab:▸\ ,eol:¬
set lazyredraw
set completeopt-=preview
set linebreak
set noshowmode
set updatetime=500

if has('nvim')
    set termguicolors
    let $NVIM_TUI_ENABLE_CURSOR_SHAPE = 1
endif

" }}}"
" # Mappings  {{{
nnoremap <leader><cr> mz?\v(".*"\|'.*')<cr>"qyl`zi<c-r>q +<cr><c-r>q<esc>
nnoremap <leader>yy gv"+y
vnoremap <leader>yy "+y
nnoremap <leader>pp "+p
vnoremap <leader>pp "+p
nnoremap <leader>PP "+P
vnoremap <leader>PP "+P
vnoremap <c-c> "+y
nnoremap <leader><leader> <c-^>
nnoremap <leader>o `>
nnoremap <leader>ss :w<cr>
nnoremap <leader>saa ggVG
nnoremap <leader>sy :setfiletype<space>
nnoremap <leader>saq ?\v('''\|""")<CR>vw//e<CR>
nnoremap <leader>siq ?\v('''\|""")<CR>wv//e<CR>ge
nnoremap <leader>sl $v^
nmap <leader>* *N
vmap <leader>* *N
vmap <leader>c* *Ncgn
nmap <leader>c* *Ncgn
nnoremap Y y$
nnoremap <leader>fw :FixWhitespace<cr>
vmap <leader>yj Jgvyu
nmap <leader>tn :tabnew<cr>
vmap <leader>tn y:tabnew<cr>p
nmap <leader>bn :vnew<cr>
vmap <leader>bn y:vnew<cr>p
nmap <leader>bc :bw<cr>
noremap <c-e> 2<c-e>
noremap <c-y> 2<c-y>
noremap gH H
noremap gL L
nnoremap <leader>; A;<esc>
nnoremap <leader><bs> $x<esc>
nnoremap <leader>= <c-w>=
nnoremap <leader>\| <c-w>\|
nnoremap <leader>_ <c-w>\|
nnoremap <leader>+ <c-w>\|<c-w>+
nnoremap <leader>cd :lcd %:p:h<cr>
nnoremap <leader>cr :ProjectRootCD<cr>
nnoremap <S-ScrollWheelUp>   <ScrollWheelLeft>
nnoremap <S-2-ScrollWheelUp> <2-ScrollWheelLeft>
nnoremap <S-3-ScrollWheelUp> <3-ScrollWheelLeft>
nnoremap <S-4-ScrollWheelUp> <4-ScrollWheelLeft>
nnoremap <S-ScrollWheelDown>     <ScrollWheelRight>
nnoremap <S-2-ScrollWheelDown>   <2-ScrollWheelRight>
nnoremap <S-3-ScrollWheelDown>   <3-ScrollWheelRight>
nnoremap <S-4-ScrollWheelDown>   <4-ScrollWheelRight>
nnoremap <silent> <leader>q :pclose<cr>:cclose<cr>:lclose<cr>:UniteClose<cr>
nnoremap <leader>sf :source %<cr>

" "}}}
" # Vim over  {{{
" Lazy loadable
nnoremap  gs  :OverCommandLine<cr>%s//g<LEFT><LEFT>
vnoremap  gs  :OverCommandLine<cr>s//g<LEFT><LEFT>
nnoremap  <leader>: :OverCommandLine<cr>
let g:over_enable_auto_nohlsearch = 0

" "}}}
" # Vim Multiple Cursors  {{{
" Lazyloadable if I disable default mappings
let g:multi_cursor_exit_from_insert_mode = 0
let g:multi_cursor_exit_from_visual_mode = 0
let g:deoplete#auto_complete_delay = 100

function! Multiple_cursors_before()
    call DeopleteMultipleCursorsSwitch(1)
endfunction

function! Multiple_cursors_after()
    call DeopleteMultipleCursorsSwitch(0)
endfunction

noremap g<c-n> :MultipleCursorsFind <c-r>/<cr>

highlight multiple_cursors_cursor term=reverse cterm=reverse gui=reverse
highlight link multiple_cursors_visual Visual

" "}}}
" # Easymotion  {{{
" Lazy loadable
let g:EasyMotion_smartcase = 1

map ; <Plug>(easymotion-prefix)
nmap f <Plug>(easymotion-bd-f)
xmap f <Plug>(easymotion-bd-f)
omap f <Plug>(easymotion-bd-f)
nmap F <Plug>(easymotion-overwin-f2)
xmap F <Plug>(easymotion-overwin-f2)
omap F <Plug>(easymotion-overwin-f2)

" "}}}
" # Vim Tmux Navigator  {{{
" Lazy loadable
let g:tmux_navigator_no_mappings = 1
nnoremap <silent> <C-H> :TmuxNavigateLeft<cr>
nnoremap <silent> <C-J> :TmuxNavigateDown<cr>
nnoremap <silent> <C-K> :TmuxNavigateUp<cr>
nnoremap <silent> <C-L> :TmuxNavigateRight<cr>
nnoremap <silent> <C-\> :TmuxNavigatePrevious<cr>

" "}}}
" # Semantic highlighting  {{{
" Lazy loadable
let g:semanticTermColors = [28,1,2,3,87,5,6,7,81,9,10,34,11,13,14,15,165,154,49,139]
nnoremap <Leader>sh :SemanticHighlightToggle<cr>

" "}}}
" # Pipe visual to shell {{{
" Plugin extractable
" By Xolox @ http://stackoverflow.com/questions/1533565/how-to-get-visually-selected-text-in-vimscript
function! s:get_visual_selection()
    let [lnum1, col1] = getpos("'<")[1:2]
    let [lnum2, col2] = getpos("'>")[1:2]
    let lines = getline(lnum1, lnum2)
    let lines[-1] = lines[-1][: col2 - (&selection == 'inclusive' ? 1 : 2)]
    let lines[0] = lines[0][col1 - 1:]
    return join(lines, "\n")
endfunction

function! s:Chomp(string)
    return substitute(a:string, '\n\+$', '', '')
endfunction

function! s:visual_command() range
    let text = s:get_visual_selection()
    let cmd = input('Pipe: ', '', 'shellcmd')
    let @v = s:Chomp(system(cmd, text))
    execute 'normal! gv"vp'
endfunction

command! -range VisualCommand <line1>,<line2>call s:visual_command()
vnoremap <leader>\| :VisualCommand<CR>

" }}} "
" # Airline  {{{
" Plugin extractable configuration?
let g:airline_powerline_fonts = 1
let g:airline_theme = 'powerlineish'
let g:airline_inactive_collapse = 1
let g:airline#extensions#branch#displayed_head_limit = 15
let g:airline#extensions#default#section_truncate_width = {}
let g:airline#extensions#tabline#show_buffers = 0
let g:airline#extensions#tabline#enabled = 1

function! AirlineInit()
    let g:airline_section_a = airline#section#create(['mode'])
    let g:airline_section_b = airline#section#create(['file', ' ', 'readonly'])
    let g:airline_section_c = airline#section#create(['%{g:unite_outline_closest_tag}'])
    let g:airline_section_x = airline#section#create([])
    let g:airline_section_y = airline#section#create(['%<', 'branch'])
    let g:airline_section_z = airline#section#create(['%p%% ', '%{g:airline_symbols.linenr}%#__accent_bold#%l%#__restore__#:%v'])
endfunction
autocmd User AirlineAfterInit call AirlineInit()

" "}}}
" # Gutentags  {{{
let g:gutentags_exclude = ['node_modules', '.git']

" "}}}
" # Deoplete  {{{
" Plugin extractable
let g:deoplete#omni#input_patterns = {}
let g:deoplete#omni#input_patterns.ruby = ['[^. *\t]\.\w*', '[a-zA-Z_]\w*::']
let g:deoplete#omni#input_patterns.javascript = '[^. *\t]\.\w*'
let g:deoplete#omni#input_patterns.vimwiki = '\[\[.*'

function! DeopleteMultipleCursorsSwitch(before)
    if a:before
        let s:old_disable_deoplete = g:deoplete#disable_auto_complete
        let g:deoplete#disable_auto_complete = 1
    else
        let g:deoplete#disable_auto_complete = s:old_disable_deoplete
    endif
endfunction

let g:deoplete#enable_at_startup = 1
let g:echodoc_enable_at_startup = 1

function! ToggleEchoDocFunc()
    if echodoc#is_enabled()
        call echodoc#disable()
    else
        call echodoc#enable()
    endif
endfunction

command! EchoDocToggle call ToggleEchoDocFunc()
nnoremap <leader>ed :<c-u>EchoDocToggle<cr>

inoremap <up> <c-p>
inoremap <down> <c-n>

" "}}}
" # UltiSnips  {{{
" Create command to load ultisnips and call it on vimenter
" Plugin extractable configuration
let g:ulti_expand_res = 0
let g:ulti_jump_forwards_res = 0
function! JumpOrExpandSnippet()
    call UltiSnips#JumpForwards()
    if !g:ulti_jump_forwards_res
        call UltiSnips#ExpandSnippet()
    endif
    return ''
endfunction

function! MyExpandSnippet()
    call UltiSnips#ExpandSnippet()
    return ''
endf

let g:UltiSnipsEditSplit           = "vertical"
xnoremap <silent> <tab> :call UltiSnips#SaveLastVisualSelection()<CR>gvs
inoremap <silent> <c-j> <c-r>=JumpOrExpandSnippet()<cr>
imap <silent> <Tab> <c-r>=MyExpandSnippet()<cr>[should]jump
inoremap <silent><expr> [should]jump g:ulti_expand_res ? '' : (pumvisible() ? "\<c-n>" : "\<tab>")
let g:UltiSnipsExpandTrigger       = "<c-t><c-t><c-t>"
let g:UltiSnipsJumpBackwardTrigger = "<c-k>"
let g:UltiSnipsSnippetsDir         = '~/.snips'
let g:UltiSnipsSnippetDirectories  = ["UltiSnips", $HOME . "/.snips"]
inoremap <c-x><c-k> <c-x><c-k>
nmap <leader>esp :UltiSnipsEdit<cr>

inoremap <silent> <c-l> <esc>:<c-u>Unite ultisnips -start-insert<cr>

" "}}}
" # ToggleList  {{{
let g:toggle_list_no_mappings = 1

" "}}}
" # NerdTREE  {{{
let NERDTreeIgnore=['\.pyc$']
nnoremap <leader>ff :NERDTreeFind<cr>

" "}}}
" # Ruby  {{{
let g:rubycomplete_buffer_loading = 1
let g:rubycomplete_classes_in_global = 1
let g:rubycomplete_use_bundler = 1
let g:rubycomplete_load_gemfile = 1

" "}}}
" # Vimux  {{{
" Plugins extractable configuration
" Prompt for a command to run
map <silent> <localleader>vp :VimuxPromptCommand<CR>
map <silent> <localleader>vl :call VimuxSendKeys('up Enter')<CR>
map <silent> <localleader>vi :VimuxInspectRunner<CR>
map <silent> <localleader>vq :VimuxCloseRunner<CR>
map <silent> <localleader>vx :VimuxInterruptRunner<CR>
map <silent> <localleader>vz :call VimuxZoomRunner()<CR>
map <silent> <localleader>vo :call VimuxOpenRunner()<CR>

" If text is selected, save it in the v buffer and send that buffer it to tmux
vmap <silent> <localleader>vs :call VimuxSlime()<CR>`>j^
vmap <silent> <localleader>vj Jgv:call VimuxSlime()<CR>u`>j^
vmap <silent> <localleader>vyp Jgv:call VimuxCopyPostres()<CR>u`>j^
vmap <silent> <localleader>v; Jgv:call VimuxSlimeSemicolon()<CR>u`>j^
vmap <silent> <localleader><CR> <localleader>vs

" Select current paragraph and send it to tmux
nmap <silent> <localleader>vs vip<localleader>vs
nmap <silent> <localleader>vj vip<localleader>vj
nmap <silent> <localleader>vyp vip<localleader>vyp
nmap <silent> <localleader>v; vip<localleader>v;
nmap <silent> <localleader><CR> V<localleader>vs
nmap <silent> <localleader>vaa ggVG<localleader>vs
nmap <silent> <localleader>vaj ggVG<localleader>vj

" Execute current file in the interpreter
nnoremap <silent> <localleader>vf :w<CR>:call VimuxRunCommand(GetExecuteCommand())<CR>
nnoremap <silent> <localleader>vw :call VimuxRunCommand(GetNodemonCommand())<CR>
nmap <silent> <localleader>vr <localleader>vq:call VimuxRunCommand(GetReplCommand())<CR>
nnoremap <silent> <localleader>vtp :call VimuxRunCommand('exec-notify ./script/test ' . expand('%'))<cr>

function! VimuxSlime() range
   call VimuxRunCommand(s:get_visual_selection())
endfunction

function! VimuxSlimeLineBreak() range
   call VimuxSlime()
   call VimuxSendKeys('Enter')
endfunction

function! VimuxSlimeSemicolon() range
   call VimuxRunCommand(s:get_visual_selection() . '\;')
endfunction

function! VimuxCopyPostres() range
   call VimuxRunCommand('\COPY (' . s:get_visual_selection() . ") TO PROGRAM 'pbcopy' DELIMITER e'\\t' CSV HEADER\;")
endfunction

function! GetExecuteCommand()
   let filetype_to_command = {
            \   'javascript': 'node',
            \   'coffee': 'coffee',
            \   'python': 'python',
            \   'html': 'open',
            \   'ruby': 'ruby',
            \   'sh': 'sh',
            \   'bash': 'bash'
            \ }
   let cmd = get(filetype_to_command, &filetype, &filetype)
   return cmd . " " . expand("%")
endfunction

function! GetNodemonCommand()
   let filetype_to_extension = {
            \   'javascript': 'js',
            \   'coffee': 'coffee',
            \   'python': 'py',
            \   'ruby': 'rb'
            \ }
   let extension = get(filetype_to_extension, &filetype, &filetype)
   let cmd = GetExecuteCommand()
   return  'nodemon -L -e "' . extension . '" -x "' . cmd . '"'
endfunction

function! GetReplCommand()
   let filetype_to_repl = {
            \   'javascript': 'node',
            \   'ruby': 'rbenv exec pry',
            \   'sql': 'pagarme_postgres'
            \ }
   let repl_bin = get(filetype_to_repl, &filetype, &filetype)
   echo repl_bin
   return  repl_bin
endfunction

" Python specific shortcuts
augroup python_vimux_shortuts
   autocmd!
   autocmd FileType python vmap <buffer> <localleader>vs :call VimuxSlimeLineBreak()<CR>`>j^
   autocmd FileType python nmap <localleader><CR> V:call VimuxSlime()<CR>`>j^
augroup END

" "}}}
" # Localvimrc  {{{
let g:localvimrc_persistent = 1
let g:avoid_standard_js_autowriter = 1
let g:localvimrc_event = ['VimEnter']

" "}}}
" # Autoformat  {{{
" Lazy configurable
noremap <leader>sb :Autoformat<cr>
let g:formatdef_sqlformat = '"sqlformat -k upper -r --indent_width=4 -"'
let g:formatdef_rubocop = '"rubocop --auto-correct " . expand("%") . " -o /dev/null || cat " . expand("%")'
let g:formatdef_standardjs = '"standard-format -"'
let g:formatters_sql = ['sqlformat']
let g:formatters_ruby = ['rubocop']

" "}}}
" # GUndo  {{{
nnoremap <leader>gu :MundoToggle<CR>

" "}}}
" # Winresizer  {{{
" Plugin extractable configuration
let g:winresizer_start_key = '<leader>wr'
let g:winresizer_keycode_left = 72
let g:winresizer_keycode_right = 76
let g:winresizer_keycode_down = 74
let g:winresizer_keycode_up = 75
nmap <leader>H <leader>wrH
nmap <leader>J <leader>wrJ
nmap <leader>K <leader>wrK
nmap <leader>L <leader>wrL

" "}}}
" # Tabularize  {{{
noremap <leader>ta :Tabularize /
noremap <leader>t/ :Tabularize /<c-r>//l1l0l0<cr>

" "}}}
" # Vim Signify  {{{
let g:signify_update_on_focusgained = 1
let g:signify_update_on_bufenter = 1

" "}}}
" # Textobj User  {{{
" Plugin extractable configuration? study possibility
call textobj#user#map('python', {
      \   'class': {
      \     'select-a': 'aP',
      \     'select-i': 'iP',
      \   },
      \ })
let g:textobj_python_no_default_key_mappings = 1

call textobj#user#map('indent', { '-': { 'select-a': 'ai', 'select-i': 'ii' } })
let g:textobj_indent_no_default_key_mappings = 1
nnoremap <leader>saq ?\v('''\|""")<CR>vw//e<CR>
nnoremap <leader>siq ?\v('''\|""")<CR>wv//e<CR>ge

" "}}}
" # Textobj column  {{{
" Plugin extractable configuration
let g:skip_default_textobj_word_column_mappings = 1
xnoremap <silent> ak :<C-u>call TextObjWordBasedColumn("aw")<cr>
xnoremap <silent> aK :<C-u>call TextObjWordBasedColumn("aW")<cr>
xnoremap <silent> ik :<C-u>call TextObjWordBasedColumn("iw")<cr>
xnoremap <silent> iK :<C-u>call TextObjWordBasedColumn("iW")<cr>
onoremap <silent> ak :call TextObjWordBasedColumn("aw")<cr>
onoremap <silent> aK :call TextObjWordBasedColumn("aW")<cr>
onoremap <silent> ik :call TextObjWordBasedColumn("iw")<cr>
onoremap <silent> iK :call TextObjWordBasedColumn("iW")<cr>

" "}}}
" # Tcommenter  {{{
let g:tcommentTextObjectInlineComment = ''

" "}}}
" # Unite.vim {{{
" Plugin extractable configuration
" Set default matcher options
" Lazy loadable?
" # Unite buffer options {{{
" Plugn extractable
call unite#custom#source('grep, outline', 'matchers', ['matcher_fuzzy'])
call unite#custom#source('grep', 'sorters', 'sorter_rank')
call unite#custom#source('location_list, quickfix', 'sorters', 'sorter_nothing')
call unite#filters#matcher_default#use(['matcher_fuzzy'])
call unite#filters#sorter_default#use(['sorter_rank'])
call unite#custom#profile('default', 'context', {
    \   'start_insert': 0,
    \   'winheight': 15,
    \   'direction': 'topleft',
    \ })

let g:unite_quickfix_is_multiline=0
call unite#custom_source('quickfix', 'converters', 'converter_quickfix_highlight')
call unite#custom_source('location_list', 'converters', 'converter_quickfix_highlight')

autocmd FileType unite call s:unite_my_settings()
function! s:unite_my_settings()
    nmap <buffer> <C-z> <Plug>(unite_toggle_transpose_window)
    imap <buffer> <C-z> <Plug>(unite_toggle_transpose_window)
    nmap <buffer> <C-j> <Plug>(unite_toggle_auto_preview)
    imap <buffer> <C-j> <Plug>(unite_toggle_auto_preview)
    nmap <buffer> <C-p> <Plug>(unite_narrowing_input_history)
    imap <buffer> <C-p> <Plug>(unite_narrowing_input_history)
    nmap <buffer> <C-r> <Plug>(unite_narrowing_input_history)
    imap <buffer> <C-r> <Plug>(unite_narrowing_input_history)
    nmap <buffer> <Tab> <Plug>(unite_complete)
    imap <buffer> <Tab> <Plug>(unite_complete)
    nmap <buffer> <C-@> <Plug>(unite_choose_action)
    imap <buffer> <C-@> <Plug>(unite_choose_action)
    nmap <buffer> <esc> <Plug>(unite_exit)
    nmap <buffer> / <Plug>(unite_insert_enter)
    nmap <buffer><expr> v unite#do_action('left')
    imap <buffer><expr> <c-v> unite#do_action('left')
endfunction
" " }}}
" # Prefix shortcuts {{{
" Plugin extractable
nnoremap [unite] <Nop>
nmap s [unite]
nnoremap <silent> [unite]r :<C-u>UniteResume<CR>
nnoremap <silent> [unite]ma :<C-u>Unite mapping<CR>
nnoremap <silent> [unite]me :<C-u>Unite output:message<CR>
nnoremap <silent> [unite]u :<C-u>Unite ultisnips<CR>
nnoremap <silent> [unite]o :<C-u>Unite -direction=topleft -split outline<CR>
nnoremap <silent> [unite]tw :<c-u>Unite tmuxcomplete -default-action=append<cr>
nnoremap <silent> [unite]tl :<c-u>Unite tmuxcomplete/lines -default-action=append<cr>
nnoremap <silent> [unite]li :<c-u>Unite line<cr>
nnoremap <silent> [unite]mr :<C-u>Unite file_mru<cr>
nnoremap <silent> [unite]f :<C-u>Unite file_mru<cr>
nnoremap <silent> [unite]/ :<C-u>Unite line -input=<c-r>/
nnoremap <silent> [unite]bb :Unite -quick-match buffer<cr>
nnoremap <silent> [unite]qf :<c-u>Unite -wrap -prompt-direction=top quickfix<cr>
nnoremap <silent> [unite]ll :<c-u>Unite -wrap -prompt-direction=top location_list<cr>
nnoremap <silent> [unite][ :<c-u>UnitePrevious<cr>
nnoremap <silent> [unite]] :<c-u>UniteNext<cr>
nnoremap <silent> [unite]{ :<c-u>UniteFirst<cr>
nnoremap <silent> [unite]} :<c-u>UniteLast<cr>
" " }}}
" Ag grep config {{{
" Plugin extractable
let g:unite_source_rec_async_command = ['ag', '--follow', '--nocolor', '--nogroup', '--hidden', '-g', '']
let g:unite_source_grep_command = 'ag'
let g:unite_source_grep_default_opts = '-i --vimgrep --hidden --ignore ' .
            \ '''.hg'' --ignore ''.svn'' --ignore ''.git'' --ignore ''.bzr'''
let g:unite_source_grep_recursive_opt = ''
let g:unite_source_line_enable_highlight = 1

nnoremap <silent> <c-f> :<c-u>Unite grep:!<cr>
nnoremap <silent> <leader>a "uyiw:<c-u>Unite grep:!::<c-r>u<cr>
vnoremap <silent> <leader>a "uy:<c-u>Unite grep:!::<c-r>u<cr>
" }}}
" Yank history mappings {{{
" Plugin extractable
nnoremap gp :<c-u>Unite history/yank -default-action=append<CR>
nnoremap gP :<c-u>Unite history/yank<CR>
vnoremap gp d:<c-u>call CallYankHistoryMaybeEnd()<cr>

function! IsAtEndOfLine()
    return col('.') == col('$') - 1 && col('.') != 1
endfunction

function! CallYankHistoryMaybeEnd()
    let action_to_take = IsAtEndOfLine() ? 'append' : 'insert'
    call unite#start(['history/yank'], { 'default_action': action_to_take })
endfunction
" }}}
" # File explorer (Ctrl+P) {{{
" Plugin extractable
let grep_source = has('nvim') ? 'file_rec/neovim' : 'file_rec/async'
nnoremap <silent> <expr> <c-p> ":\<C-u>Unite -buffer-name=files " . grep_source . ":! file/new\<CR>"
vnoremap <silent> <expr> gf "\"uy:\<C-u>Unite -buffer-name=files " . grep_source . ":! -input=\<c-r>u\<CR>"
nmap <silent> gf viwgf

" "}}}
" # Unimpaired {{{

" "}}}
" # Outline {{{
" Plugin extractable closest tag -> include in vim outline Pull request?
let g:unite_source_outline_highlight = {
\ 'comment' : 'Comment',
\ 'expanded': 'Constant',
\ 'function': 'Function',
\ 'id'      : 'Special',
\ 'macro'   : 'Macro',
\ 'method'  : 'Function',
\ 'normal'  : 'Normal',
\ 'package' : 'Normal',
\ 'special' : 'Macro',
\ 'type'    : 'Type',
\ 'level_1' : 'Type',
\ 'level_2' : 'PreProc',
\ 'level_3' : 'Identifier',
\ 'level_4' : 'Constant',
\ 'level_5' : 'Special',
\ 'level_6' : 'Normal',
\ 'parameter_list': 'Normal',
\ }

let g:unite_outline_closest_tag = ''
function! GetClosestTag()
   silent let candidates = unite#get_candidates(['outline'])

   if empty(candidates)
      return ''
   endif

   let curline = line('.')
   let prevtag = ''
   let prevword = ''
   let accscope = ''

   for candidate in candidates
      if candidate.action__line > curline
         break
      endif

      if prevword != '' && candidate.action__signature =~ prevword
         let accscope = accscope == '' ? prevword : accscope . '#' . prevword
         let prevtag = accscope . '#' . candidate.abbr
      else
         let accscope = ''
         let prevtag = candidate.abbr
      endif

      let prevword = candidate.word
   endfor

   return prevtag
endfunction
command! GetClosestTag echo GetClosestTag()
nnoremap <silent> <esc> :let g:unite_outline_closest_tag = GetClosestTag()<cr>
autocmd CursorHold * let g:unite_outline_closest_tag = GetClosestTag()

" "}}}
" # Other mappings {{{
nnoremap <silent> <leader><c-o> :<c-u>Unite jump<cr>
nmap <leader>epv :<c-u>Unite -input=.lvimrc file_rec/neovim<cr>
nmap <leader>spv :<c-u>LocalVimRC<cr>
nmap <leader>epg :<c-u>Unite file_rec/neovim:~/.vim/plugged<cr>
" "}}}
" " }}}
" # Indent guides configuration Neovim  {{{
let g:indent_guides_auto_colors = 0
hi IndentGuidesOdd  guibg=#353738 ctermbg=none
hi IndentGuidesEven guibg=#252627 ctermbg=black

" "}}}
" # Neomake  {{{
" Lazy loadable
augroup neomake_save_linter
    autocmd!
    autocmd BufWritePost * Neomake
augroup end
let g:neomake_javascript_standard_maker = { 'errorformat': '%E %f:%l:%c: %m' }

" "}}}
" # Vim autoswap  {{{
let g:autoswap_detect_tmux = 1

" "}}}
" # Delimitmate  {{{
" Extractable configuration
function! DelimitMateCompletion(key)
    " Because of a Deoplete bug, I have to repeat a key to try to restore
    " original vim behaviour
    return (delimitMate#ShouldJump() ? "\<Del>" : "")
                \ . "\<c-x>" . a:key . (pumvisible() ? a:key : "")
endfunction

function! CustomCompletion(key)
    return "\<c-x>" . a:key . (pumvisible() ? a:key : "")
endfunction

imap <expr> <c-x><c-l> DelimitMateCompletion("\<c-l>")
imap <expr> <c-x><c-n> CustomCompletion("\<c-n>")
imap <expr> <c-x><c-p> CustomCompletion("\<c-p>")
let g:delimitMate_expand_space = 1
let g:delimitMate_expand_cr = 1

if !exists('g:set_carriage_return')
    imap <CR> <C-G>u<Plug>delimitMateCR
    let g:set_carriage_return = 1
endif

augroup R_specific_settings
    au!
    au FileType R,rmd let b:delimitMate_matchpairs = "(:),[:],{:}"
augroup END


" "}}}
" # Windowswap  {{{
let g:windowswap_map_keys = 0 "prevent default bindings
nnoremap <silent> <leader>sw :call WindowSwap#EasyWindowSwap()<CR>

" "}}}
" # Vimwiki  {{{
" Extractable configuration
let g:vimwiki_list = [{'path': '~/Dropbox/Apps/vimwiki/wiki', 'path_html': '~/Dropbox/Apps/vimwiki/html'}]

nnoremap [d :VimwikiDiaryPrevDay<cr>
nnoremap ]d :VimwikiDiaryNextDay<cr>

" "}}}
" # Schlepp  {{{
" Extractable configuration
" Lazy loadable
if !exists('g:set_schlepp_shortcuts')
    vmap <unique> <up>    <Plug>SchleppUp
    vmap <unique> <down>  <Plug>SchleppDown
    vmap <unique> <left>  <Plug>SchleppLeft
    vmap <unique> <right> <Plug>SchleppRight
    vmap <unique> D       <Plug>SchleppDup
    let g:set_schlepp_shortcuts = 1
endif

" "}}}
" # incsearch.vim  {{{
" Extractable configuration
" Lazy loadable
map g/ <Plug>(incsearch-stay)
" "}}}
