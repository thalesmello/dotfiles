let maplocalleader = "'"
" Mappings
nnoremap <leader>elv :vsplit ~/.vimrc.local<cr>
nnoremap <leader>slv :source ~/.vimrc.local<cr>
nnoremap <leader>. `>
nnoremap <leader>ss :w<cr>
nnoremap <leader>saa ggVG
nnoremap <leader>sp V$%
nnoremap <leader>saq ?\v('''\|""")<CR>vw//e<CR>
nnoremap <leader>siq ?\v('''\|""")<CR>wv//e<CR>ge
nmap <leader>tb :TagbarToggle<CR>
nmap <leader>/ *N
vmap <leader>/ *N
vmap <leader>c/ *Ncgn
nmap <leader>c/ *Ncgn
nmap <leader>of vafzO
inoremap <c-u> <c-g>u<c-u>
inoremap <c-w> <c-g>u<c-w>
vmap <leader>yj Jgvyu
nmap <leader>tn :tabnew<cr>
vmap <leader>tn y:tabnew<cr>p
nmap <leader>bn :vnew<cr>
vmap <leader>bn y:vnew<cr>p
nmap <leader>bc :bw<cr>

" Set unnamed register as default clipboard
set clipboard=unnamed

" Tmux complete
nnoremap <leader>ut :set completefunc=tmuxcomplete#complete<cr>
nnoremap <leader>uy :set completefunc=youcompleteme#Complete<cr>
let g:tmuxcomplete#capture_args = '-J -S -'

inoremap <C-l> <C-x><C-l>
inoremap <C-f> <C-x><C-f>
inoremap <C-j> <C-x><C-u>
" Map multicursors

" Easyclip
let g:EasyClipEnableBlackHoleRedirect = 0
let g:EasyClipUsePasteToggleDefaults = 0
let g:EasyClipUseCutDefaults = 0
nmap <leader>yp <plug>EasyClipSwapPasteForward
nmap <leader>yn <plug>EasyClipSwapPasteBackwards
nmap d <Plug>MoveMotionPlug
xmap d <Plug>MoveMotionXPlug
nmap dd <Plug>MoveMotionLinePlug

" Submode yank toggle
call submode#enter_with('yank_p/n', 'n', 'r', '<leader><', '<leader>yp')
call submode#enter_with('yank_p/n', 'n', 'r', '<leader>>', '<leader>yn')
call submode#map('yank_p/n', 'n', 'r', '<', '<leader>yp')
call submode#map('yank_p/n', 'n', 'r', '>', '<leader>yn')

" Called once right before you start selecting multiple cursors
function! Multiple_cursors_before()
	let s:old_ycm_auto_trigger = g:ycm_auto_trigger
	let g:ycm_auto_trigger = 0
endfunction

" Called once only when the multiple selection is canceled (default <Esc>)
function! Multiple_cursors_after()
	let g:ycm_auto_trigger = s:old_ycm_auto_trigger
endfunction

nmap <c-n> :call multiple_cursors#new("n", 1)<CR>
let g:multi_cursor_exit_from_insert_mode = 0
let g:multi_cursor_exit_from_visual_mode = 0
highlight multiple_cursors_cursor term=reverse cterm=reverse gui=reverse
highlight link multiple_cursors_visual Visual
set wildmode=list:longest,full

set listchars=tab:▸\ ,eol:¬

" Tagbar
let g:tagbar_left = 1
let g:tagbar_autoclose = 1
let g:tagbar_autofocus = 1
set updatetime=500

if &term =~ '^screen'
    " tmux knows the extended mouse mode
    set ttymouse=xterm2
endif

" Sneak
nmap f <Plug>(SneakStreak)
nmap F <Plug>(SneakStreakBackward)
xmap f <Plug>(SneakStreak)
xmap F <Plug>(SneakStreakBackward)
omap f <Plug>(SneakStreak)
omap F <Plug>(SneakStreakBackward)
let g:sneak#use_ic_scs = 1

nnoremap <F6> :resize -5<CR>
nnoremap <F7> :resize +5<CR>
nnoremap <F8> :vertical resize -5<CR>
nnoremap <F9> :vertical resize +5<CR>


set lazyredraw

" Don't wait for ESC to timeout
set timeoutlen=1000 ttimeoutlen=0

" Vim Tmux Navigator
let g:tmux_navigator_no_mappings = 1
nnoremap <silent> <C-H> :TmuxNavigateLeft<cr>
nnoremap <silent> <C-J> :TmuxNavigateDown<cr>
nnoremap <silent> <C-K> :TmuxNavigateUp<cr>
nnoremap <silent> <C-L> :TmuxNavigateRight<cr>
nnoremap <silent> <C-\> :TmuxNavigatePrevious<cr>

set linebreak

" Devdocs
augroup plugin-devdocs
  autocmd!
  autocmd FileType c,cpp,rust,haskell,python,javascript,html,eruby,ruby nmap <buffer>K <Plug>(devdocs-under-cursor)
  autocmd FileType c,cpp,rust,haskell,python,javascript,html,eruby,ruby vmap <buffer>K y:DevDocs <C-R>"<CR>
  autocmd FileType * nmap <buffer>gK <Plug>(devdocs-under-cursor-all)
  autocmd FileType * vmap <buffer><silent>gK y:DevDocsAll <C-R>"<CR>
augroup END
let g:devdocs_filetype_map = {
    \   'ruby': 'ruby',
    \ }

" Remove yankstack enter mapping
" nunmap <cr>

" Semantic highlighting
let g:semanticTermColors = [28,1,2,3,87,5,6,7,81,9,10,34,11,13,14,15,165,154,49,139]
nnoremap <Leader>sh :SemanticHighlightToggle<cr>

" Automatic variable highlighting
" augroup color-variable
" 	autocmd!
" 	autocmd CursorMoved * exe printf('match Label /\V\<%s\>/', escape(expand('<cword>'), '/\'))
" augroup end

" Greplace options
set grepprg=ack
let g:grep_cmd_opts = '--noheading'

" Go to file ctrlp
nmap gf <c-p><c-\>w
vmap gf <esc><c-p><c-\>v

" Ack Options
if executable('ag')
    let g:ackprg ='ag --vimgrep'
endif

" By Xolox @ http://stackoverflow.com/questions/1533565/how-to-get-visually-selected-text-in-vimscript
function! s:get_visual_selection()
  " Why is this not a built-in Vim script function?!
  let [lnum1, col1] = getpos("'<")[1:2]
  let [lnum2, col2] = getpos("'>")[1:2]
  let lines = getline(lnum1, lnum2)
  let lines[-1] = lines[-1][: col2 - (&selection == 'inclusive' ? 1 : 2)]
  let lines[0] = lines[0][col1 - 1:]
  return join(lines, "\n")
endfunction

function! s:Chomp(string)
    return substitute(a:string, '\n\+$', '', '')
endfunction

function! s:visual_command() range
   let text = s:get_visual_selection()
   let cmd = input('Pipe: ', '', 'shellcmd')
   let out = s:Chomp(system(cmd, text))
   execute "normal! gvc\<C-R>=out\<CR>"
endfunction

command! -range VisualCommand <line1>,<line2>call s:visual_command()
vnoremap <leader>\| :VisualCommand<CR>

" Airline
let g:airline#extensions#tagbar#enabled = 1
let g:airline#extensions#tagbar#flags = 'f'
let g:airline#extensions#branch#displayed_head_limit = 15
let g:airline#extensions#ycm#enabled = 1
let g:airline#extensions#virtualenv#enabled = 0
let g:airline#extensions#default#section_truncate_width = {}
let g:airline#extensions#tabline#enabled = 1
function! AirlineInit()
	let g:airline_section_a = airline#section#create(['mode'])
	let g:airline_section_b = airline#section#create(['file', ' ', 'readonly'])
	let g:airline_section_c = airline#section#create(['tagbar'])
	let g:airline_section_x = airline#section#create([])
	let g:airline_section_y = airline#section#create(['%<', 'branch'])
	let g:airline_section_z = airline#section#create(['%p%% ', '%{g:airline_symbols.linenr}%#__accent_bold#%l%#__restore__#:%v'])
endfunction
autocmd User AirlineAfterInit call AirlineInit()

" Gutentags
let g:gutentags_exclude = ['node_modules', '.git']

" YouCompleteMe
nnoremap <leader>ycm :let g:ycm_auto_trigger = !g:ycm_auto_trigger<cr>

nnoremap <leader>gtd :YcmCompleter GoToDefinition<cr>
nnoremap <leader>gtr :YcmCompleter GoToReferences<cr>:cclose<cr>:copen<cr>
nnoremap <leader>gtk :YcmCompleter GetDoc<cr>
nnoremap <leader>gtt :YcmCompleter GetType<cr>
nnoremap <leader>rv :YcmCompleter RefactorRename<space>
nnoremap <leader>q :pclose<cr>:cclose<cr>
let g:ycm_path_to_python_interpreter = '/usr/bin/python2.7'

" Snipmate
imap <C-K> <Plug>snipMateNextOrTrigger
smap <C-K> <Plug>snipMateNextOrTrigger

" ToggleList
let g:toggle_list_no_mappings = 1

" NerdTREE
let NERDTreeIgnore=['\.pyc$']

" Ruby
let g:rubycomplete_buffer_loading = 1
let g:rubycomplete_classes_in_global = 1

" Vimux
" Prompt for a command to run
map <localleader>vp :VimuxPromptCommand<CR>
" Run last command executed by VimuxRunCommand
map <localleader>vl :VimuxRunLastCommand<CR>
" Inspect runner pane
map <localleader>vi :VimuxInspectRunner<CR>
" Close vim tmux runner opened by VimuxRunCommand
map <localleader>vq :VimuxCloseRunner<CR>
" Interrupt any command running in the runner pane
map <localleader>vx :VimuxInterruptRunner<CR>
" Zoom the runner pane (use <bind-key> z to restore runner pane)
map <localleader>vz :call VimuxZoomRunner()<CR>

function! VimuxSlime() range
	let text = s:get_visual_selection()
	call VimuxSendText(text)
	call VimuxSendKeys("Enter")
endfunction

function! VimuxSlimeSemicolon() range
	let text = s:get_visual_selection() . '\;'
	call VimuxSendText(text)
	call VimuxSendKeys("Enter")
endfunction

" If text is selected, save it in the v buffer and send that buffer it to tmux
vmap <localleader>vs :call VimuxSlime()<CR>
vmap <localleader>vj Jgv:call VimuxSlime()<CR>u
vmap <localleader>v; Jgv:call VimuxSlimeSemicolon()<CR>u

" Select current paragraph and send it to tmux
nmap <localleader>vs vip<LocalLeader>vs<CR>

" Ctrlp
let g:ctrlp_custom_ignore = '\v([\/]\.(git|hg|svn)$)|\.pyc$'

" Localvimrc
:let g:localvimrc_persistent = 1

" Autoformat
noremap <leader>sb :Autoformat<cr>
let g:formatdef_sqlformat = '"sqlformat -k upper -r --indent_width=4 -"'
let g:formatters_sql = ['sqlformat']

" Autoft
let g:autoft_config = [
			\ { 'filetype': 'html' , 'pattern': '<\%(!DOCTYPE\|html\|head\|script\)' },
			\ { 'filetype': 'c'    , 'pattern': '^\s*#\s*\%(include\|define\)\>' },
			\ { 'filetype': 'diff' , 'pattern': '^diff -' },
			\ { 'filetype': 'sh'   , 'pattern': '^#!.*\%(\<sh\>\|\<bash\>\)\s*$' },
			\ { 'filetype': 'sql'  , 'pattern': '^\s*SELECT.*$' },
			\ ]
